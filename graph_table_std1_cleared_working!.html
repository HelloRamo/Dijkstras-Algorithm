<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Shortest path Dijkstra algorithm by Ramo</title>
    <style>  
        body {
            margin: 0;
            display: flex;
            justify-content: space-between;
        }
        #graphContainer {
            flex-grow: 1;
        }
        canvas {
            border: 1px solid black;
            width: 100%;
        }
        #sideContainer {
            width: 300px; /* Adjust the width as needed */
            padding: 20px;
            box-sizing: border-box;
            text-align: left;
        }
        #output, #priorityQueueOutput {
            margin-top: 20px;
            font-family: Arial;
        }
        #distanceTable, #distanceTable th, #distanceTable td {
            border: 1px solid black; border-collapse: collapse; padding: 5px;
        }
        #distanceTable {
            margin-bottom: 20px;
        }
        input {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <div id="mainContainer">
        <canvas id="graphCanvas" width="800" height="600"></canvas>
        <div id="inputOutputContainer">
            <div id="outputDiv"></div>
        
                <script>
                let canvas = document.getElementById('graphCanvas');
                let ctx = canvas.getContext('2d');
                let outputDiv = document.getElementById('output');

                const nodes = {
                    A: { x: 150, y: 300 },
                    B: { x: 250, y: 150 },
                    C: { x: 50, y: 150 },
                    D: { x: 250, y: 450 },
                    E: { x: 400, y: 300 },
                    F: { x: 350, y: 500 },
                    G: { x: 50, y: 450 },
                    H: { x: 550, y: 150 },
                    I: { x: 600, y: 450 },
                    J: { x: 750, y: 300 },
                };

                const edges = [
                    { from: 'A', to: 'B' },
                    { from: 'A', to: 'C' },
                    { from: 'A', to: 'D' },
                    { from: 'B', to: 'C' },
                    { from: 'B', to: 'D' },
                    { from: 'B', to: 'E' },
                    { from: 'B', to: 'H' },
                    { from: 'C', to: 'G' },
                    { from: 'D', to: 'F' },
                    { from: 'D', to: 'E' },
                    { from: 'E', to: 'H' },
                    { from: 'E', to: 'I' },
                    { from: 'E', to: 'J' },
                    { from: 'F', to: 'G' },
                    { from: 'F', to: 'I' },
                    { from: 'G', to: 'I' },
                    { from: 'G', to: 'D' },
                    { from: 'H', to: 'J' },
                    { from: 'I', to: 'J' },
                ];

                edges.forEach(edge => {
                    edge.weight = Math.floor(Math.random() * 31 + 1);
                });
       
                  /*
                    This code defines a class PriorityQueue and a function dijkstra for implementing Dijkstra's algorithm.
                    The PriorityQueue class is used to store elements with their respective priorities and provides methods for enqueueing and dequeueing elements.
                    The dijkstra function calculates the shortest distances from a given start node to all other nodes in a graph using Dijkstra's algorithm.
                    It uses a priority queue to efficiently process nodes based on their distances.
                    The function returns an object containing the calculated distances and the previous nodes in the shortest paths.   
                 */

                class PriorityQueue {
                    constructor() {
                        this.queue = [];
                    }

                    enqueue(element, priority) {
                        this.queue.push({ element, priority });
                        this.sort();
                    }

                    dequeue() {
                        if (this.isEmpty()) {
                            return "Queue is empty";
                        }
                        return this.queue.shift().element;
                    }

                    isEmpty() {
                        return this.queue.length === 0;
                    }

                    sort() {
                        this.queue.sort((a, b) => a.priority - b.priority);
                    }
                }
                function dijkstra(start) {
                    const distances = {};
                    const prev = {};
                    const priorityQueue = new PriorityQueue();

                    Object.keys(nodes).forEach(node => {
                        distances[node] = Infinity;
                        prev[node] = null;
                    });

                    distances[start] = 0;
                    priorityQueue.enqueue(start, 0);

                    while (!priorityQueue.isEmpty()) {
                        let current = priorityQueue.dequeue();

                        edges.filter(edge => edge.from === current || edge.to === current).forEach(edge => {
                            let otherNode = edge.from === current ? edge.to : edge.from;
                            let weight = edge.weight;

                            if (distances[current] + weight < distances[otherNode]) {
                                distances[otherNode] = distances[current] + weight;
                                prev[otherNode] = current;
                                priorityQueue.enqueue(otherNode, distances[otherNode]);
                            }
                        });
                    }

                    return { distances, prev };
                }


        // starting from A shortest path is stored in variable result
        const result = dijkstra('A');
        
        // Drawing a line between two nodes to represent the edge.
        edges.forEach(edge => {
            ctx.beginPath();
            ctx.moveTo(nodes[edge.from].x, nodes[edge.from].y);
            ctx.lineTo(nodes[edge.to].x, nodes[edge.to].y);
            ctx.stroke();
            let midX = (nodes[edge.from].x + nodes[edge.to].x) / 2;
            let midY = (nodes[edge.from].y + nodes[edge.to].y) / 2;
            ctx.font = '20px Arial';
            ctx.fillText(edge.weight, midX, midY);
        });
        
        // Drawing the nodes as circles
        for (let node in nodes) {
            ctx.beginPath();
            ctx.arc(nodes[node].x, nodes[node].y, 20, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(node, nodes[node].x - 10, nodes[node].y + 7);
        }
                

 </script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"> <!-- Declare character encoding for the HTML document -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Set the viewport width to device width and initial zoom to 1 -->
    <title>Graph Shortest Path Input</title>
    <!-- Provide styling for the HTML elements -->
    <style> 
    #distanceTable, #distanceTable th, #distanceTable td { border: 1px solid black; border-collapse: collapse; padding: 15px; }
    #distanceTable { 
        position: relative; /*  fixes the position of the element relative to the browser window */
        top: 10; /* Specifies distance from top of window */
        right: 50; /* Specifies distance from right of window */
        margin-bottom: 20px; 
    }
    input { margin-right: 12px; }
    #canvasContainer {
            flex: 1;
        }
        #tableContainer {
            flex: 1;
        }
        #mainContainer {
            display: flex;
            justify-content: center; /* Center the flex items horizontally */
            align-items: start; /* Align the flex items to the top */
        }
</style>
</head>
<body>
    <div id="mainContainer">
        <div id="canvasContainer">
        </div>
        <div id="tableContainer">
        </div>
    </div>
    <div>


    <h3>Enter the shortest distances from node A to each node:</h3>
    <table id="distanceTable"> <!-- Define a table to capture user inputs -->
        <tr>
            <th>Knoten</th>
            <th>Kosten</th>
            <th>Action</th>
        </tr>
 <!-- Repeat this structure for each distance input to nodes A to J -->
            <tr>
                <td>A</td>
                <td>0</td>
                <td></td>
            </tr>
        
            <tr>
                <td>B</td>
                <td>
                    <input type="text" id="distanceToB" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('B')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>C</td>
                <td>
                    <input type="text" id="distanceToC" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('C')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>D</td>
                <td>
                    <input type="text" id="distanceToD" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('D')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>E</td>
                <td>
                    <input type="text" id="distanceToE" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('E')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>F</td>
                <td>
                    <input type="text" id="distanceToF" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('F')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>G</td>
                <td>
                    <input type="text" id="distanceToG" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('G')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>H</td>
                <td>
                    <input type="text" id="distanceToH" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('H')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>I</td>
                <td>
                    <input type="text" id="distanceToI" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('I')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>J</td>
                <td>
                    <input type="text" id="distanceToJ" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('J')">Verify</button>
                </td>
            </tr>
        
    </table>
</div>

    
<script>
    const startNode = 'A';
    const dijkstraResult = dijkstra(startNode);
    var correctDistances = result.distances;
var userAnswers = {'A': 0}; // Create a dictionary to store user inputs

// This function verifies user input against the correct distances
function validateInput(node) {
    var userInput = document.getElementById('distanceTo' + node).value;
    var distanceTable = document.getElementById('distanceTable');

    // If the user input is correct, store it and give feedback
    if (correctDistances[node] == userInput) {
        userAnswers[node] = userInput;
        alert('Correct! The distance to node ' + node + ' is ' + userInput + '.'); // Alert for correct input
        if (Object.keys(userAnswers).length === Object.keys(correctDistances).length + 1) {
            displayResults();
        } else {
            var nextNode = String.fromCharCode('A'.charCodeAt(0) + Object.keys(userAnswers).length);
            var nextInput = document.getElementById('distanceTo' + nextNode);
            if (nextInput) {
                nextInput.focus();
            }
        }
    } else {
        alert('Incorrect for node ' + node + '. Try again.'); // If  wrong, prompt for another try
    }
}

// This function displays the user's entered distances at the end
function displayResults() {
    var message = document.createElement('div');
    message.innerHTML = '<strong>Shortest distances from A:</strong><br>';
    Object.keys(userAnswers).sort().forEach(function(node) {
        message.innerHTML += 'Node ' + node + ': ' + userAnswers[node] + '<br>';
    });
    distanceTable.parentNode.insertBefore(message, distanceTable.nextSibling);
}
</script>

</body>
</html>
