<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest path Dijkstra algorithm by Ramo</title>
    <style>  
        body {
            margin: 0;
            display: flex;
            justify-content: space-between;
        }
        #graphContainer {
            flex-grow: 1;
        }
        canvas {
            border: 1px solid black;
            width: 100%;
        }
        #sideContainer {
            width: 300px; /* Adjust the width as needed */
            padding: 20px;
            box-sizing: border-box;
            text-align: left;
        }
        #output, #priorityQueueOutput {
            margin-top: 20px;
            font-family: Arial;
        }
        #distanceTable, #distanceTable th, #distanceTable td {
            border: 1px solid black; border-collapse: collapse; padding: 5px;
        }
        #distanceTable {
            margin-bottom: 20px;
        }
        input {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <div id="mainContainer">
        <canvas id="graphCanvas" width="800" height="600"></canvas>
        <div id="inputOutputContainer">
            <div id="outputDiv"></div>
        
            <script>
                // Your existing JavaScript variables and functions (nodes, edges, etc.)
        /*
                document.getElementById('startButton').addEventListener('click', function() {
                    let startNode = document.getElementById('startNodeInput').value;
        
                    // Validate the input
                    if (!nodes[startNode]) {
                        alert("Invalid start node!");
                        return;
                    }
        
                    // Run Dijkstra's algorithm
                    const result = dijkstra(startNode);
        
                    // Existing code to draw the graph
        
                    // Create output text for the results
                    /*
                    let outputText = `<strong>Distances from ${startNode}:</strong><br>`;
                    for (let node in result.distances) {
                        outputText += `${node}: ${result.distances[node]}<br>`;
                    }
                    outputText += "<br><strong>Previous nodes:</strong><br>";
                    for (let node in result.prev) {
                        outputText += `${node}: ${result.prev[node]}<br>`;
                    }
                    
                    // Display the results
                    document.getElementById('outputDiv').innerHTML = outputText;
                });
        */
                // Your existing Dijkstra's function here
            </script>
        </body>
        </html>
            <script>
                let canvas = document.getElementById('graphCanvas');
                let ctx = canvas.getContext('2d');
                let outputDiv = document.getElementById('output');
        
                const nodes = {
                    A: { x: 150, y: 300 },
                    B: { x: 250, y: 150 },
                    C: { x: 50, y: 150 },
                    D: { x: 250, y: 450 },
                    E: { x: 400, y: 300 },
                    F: { x: 350, y: 500 },
                    G: { x: 50, y: 450 },
                    H: { x: 550, y: 150 },
                    I: { x: 600, y: 450 },
                    J: { x: 750, y: 300 },
                    /*
                    K: { x: 450, y: 200 },  // Coordinates for new nodes K, L, M, N, O
                    L: { x: 500, y: 350 },  // These are example coordinates and should be adjusted
                    M: { x: 600, y: 200 },
                    N: { x: 650, y: 350 },
                    O: { x: 700, y: 250 }
                    */
                };
        
                const edges = [
                    { from: 'A', to: 'B' },
                    { from: 'A', to: 'C' },
                    { from: 'A', to: 'D' },
                    { from: 'B', to: 'C' },
                    { from: 'B', to: 'D' },
                    { from: 'B', to: 'E' },
                    { from: 'B', to: 'H' },
                    { from: 'C', to: 'G' },
                    { from: 'D', to: 'F' },
                    { from: 'D', to: 'E' },
                    { from: 'E', to: 'H' },
                    { from: 'E', to: 'I' },
                    { from: 'E', to: 'J' },
                    { from: 'F', to: 'G' },
                    { from: 'F', to: 'I' },
                    { from: 'G', to: 'I' },
                    { from: 'G', to: 'D' },
                    { from: 'H', to: 'J' },
                    { from: 'I', to: 'J' },
                    /*
                    { from: 'K', to: 'L' },
                    { from: 'L', to: 'M' },
                    { from: 'M', to: 'N' },
                    { from: 'N', to: 'O' },
                    */
                ];
        
                edges.forEach(edge => {
                    edge.weight = Math.floor(Math.random() * 31+1);
                });
                class PriorityQueue {
    constructor() {
        this.queue = [];
    }

    enqueue(element, priority) {
        const queueElement = { element, priority };
        let added = false;

        for (let i = 0; i < this.queue.length; i++) {
            if (queueElement.priority < this.queue[i].priority) {
                this.queue.splice(i, 0, queueElement);
                added = true;
                break;
            }
        }

        if (!added) {
            this.queue.push(queueElement);
        }
    }

    dequeue() {
        if (this.isEmpty()) {
            return null;
        }
        return this.queue.shift().element;
    }

    isEmpty() {
        return this.queue.length === 0;
    }
}

function dijkstra(graph, startNode, endNode) {
    const distances = {};
    const previous = {};
    const pq = new PriorityQueue();

    // Initialization
    for (let node in graph) {
        distances[node] = node === startNode ? 0 : Infinity;
        previous[node] = null;
    }

    pq.enqueue(startNode, 0);

    while (!pq.isEmpty()) {
        let minNode = pq.dequeue();

        for (let neighbor in graph[minNode]) {
            let newDistance = distances[minNode] + graph[minNode][neighbor];

            if (newDistance < distances[neighbor]) {
                distances[neighbor] = newDistance;
                previous[neighbor] = minNode;
                pq.enqueue(neighbor, newDistance);
            }
        }
    }

    // Build the shortest path
    let shortestPath = [];
    let currentNode = endNode;

    while (currentNode !== null) {
        shortestPath.unshift(currentNode);
        currentNode = previous[currentNode];
    }

    return shortestPath;
}
                /*
                function dijkstra(start) {
                    const distances = {};
                    const visited = {};
                    const prev = {};
                    const priorityQueue = new PriorityQueue();
                
                    const nodesArray = Object.keys(nodes);
                    nodesArray.forEach(node => {
                        distances[node] = Infinity;
                        visited[node] = false;
                    });
                
                    distances[start] = 0;
                    priorityQueue.enqueue(start, 0);
                
                    while (!priorityQueue.isEmpty()) {
                        const current = priorityQueue.dequeue();
                        visited[current] = true;
                
                        edges.filter(edge => edge.from === current || edge.to === current).forEach(edge => {
                            const otherNode = edge.from === current ? edge.to : edge.from;
                
                            if (!visited[otherNode]) {
                                const weight = distances[current] + edge.weight;
                
                                if (weight < distances[otherNode]) {
                                    distances[otherNode] = weight;
                                    prev[otherNode] = current;
                                    priorityQueue.enqueue(otherNode, weight);
                                }
                            }
                        });
                    }
                
                    return { distances, prev };
                }
                
                const result = dijkstra('A');
                */
                // Drawing a line between two nodes to represent the edge.
                edges.forEach(edge => {
                    ctx.beginPath();
                    ctx.moveTo(nodes[edge.from].x, nodes[edge.from].y);
                    ctx.lineTo(nodes[edge.to].x, nodes[edge.to].y);
                    ctx.stroke();
                    let midX = (nodes[edge.from].x + nodes[edge.to].x) / 2;
                    let midY = (nodes[edge.from].y + nodes[edge.to].y) / 2;
                    ctx.font = '20px Arial';
                    ctx.fillText(edge.weight, midX, midY);
                });
                
                // Drawing the nodes as circles
                for (let node in nodes) {
                    ctx.beginPath();
                    ctx.arc(nodes[node].x, nodes[node].y, 20, 0, 2 * Math.PI);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.stroke();
                    ctx.fillStyle = 'black';
                    ctx.font = '20px Arial';
                    ctx.fillText(node, nodes[node].x - 10, nodes[node].y + 7);
                }
                
                // Output table for each node and its priority queue
                for (let node in nodes) {
                    const outputTable = document.createElement('table');
                    outputTable.id = `${node}Table`;
                    outputTable.style.marginTop = '20px';
                    outputTable.style.fontFamily = 'Arial';
                    outputTable.style.borderCollapse = 'collapse';
                    outputTable.style.border = '1px solid black';
                    outputTable.innerHTML = `
                        <tr>
                            <th colspan="2">${node}</th>
                        </tr>
                        <tr>
                            <th>Node</th>
                            <th>Distance</th>
                        </tr>
                    `;
                
                    for (let n in result.distances) {
                        const row = document.createElement('tr');
                        const nodeCell = document.createElement('td');
                        const distanceCell = document.createElement('td');
                
                        nodeCell.textContent = n;
                        distanceCell.textContent = result.distances[n];
                
                        row.appendChild(nodeCell);
                        row.appendChild(distanceCell);
                        outputTable.appendChild(row);
                    }
                
                    outputDiv.appendChild(outputTable);
                }
        // END: ed8c6549bwf9

                /*
                                for (let node in result.distances) {
                    outputText += `${node}: ${result.distances[node]}<br>`;
                }
                outputText += "<br><strong>Previous nodes:</strong><br>";
                for (let node in result.prev) {
                    outputText += `${node}: ${result.prev[node]}<br>`;
                }
                
                outputDiv.innerHTML = outputText;
                */
            </script>
        </body>
        </html>  


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"> <!-- Declare character encoding for the HTML document -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Set the viewport width to device width and initial zoom to 1 -->
    <title>Graph Shortest Path Input</title>
    <!-- Provide styling for the HTML elements -->
    <style> 
    #distanceTable, #distanceTable th, #distanceTable td { border: 1px solid black; border-collapse: collapse; padding: 15px; }
    #distanceTable { 
        position: relative; /*  fixes the position of the element relative to the browser window */
        top: 10; /* Specifies distance from top of window */
        right: 50; /* Specifies distance from right of window */
        margin-bottom: 20px; 
    }
    input { margin-right: 12px; }
    #canvasContainer {
            flex: 1;
        }
        #tableContainer {
            flex: 1;
        }
        #mainContainer {
            display: flex;
            justify-content: center; /* Center the flex items horizontally */
            align-items: start; /* Align the flex items to the top */
        }
</style>
</head>
<body>
    <div id="mainContainer">
        <div id="canvasContainer">
        </div>
        <div id="tableContainer">
        </div>
    </div>
    <div>


    <h3>Enter the shortest distances from node A to each node:</h3>
    <table id="distanceTable"> <!-- Define a table to capture user inputs -->
        <tr>
            <th>Knoten</th>
            <th>Kosten</th>
            <th>Action</th>
        </tr>
 <!-- Repeat this structure for each distance input to nodes A to J -->
            <tr>
                <td>A</td>
                <td>0</td>
                <td></td>
            </tr>
        
            <tr>
                <td>B</td>
                <td>
                    <input type="text" id="distanceToB" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('B')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>C</td>
                <td>
                    <input type="text" id="distanceToC" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('C')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>D</td>
                <td>
                    <input type="text" id="distanceToD" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('D')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>E</td>
                <td>
                    <input type="text" id="distanceToE" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('E')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>F</td>
                <td>
                    <input type="text" id="distanceToF" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('F')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>G</td>
                <td>
                    <input type="text" id="distanceToG" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('G')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>H</td>
                <td>
                    <input type="text" id="distanceToH" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('H')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>I</td>
                <td>
                    <input type="text" id="distanceToI" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('I')">Verify</button>
                </td>
            </tr>
        
            <tr>
                <td>J</td>
                <td>
                    <input type="text" id="distanceToJ" placeholder="Distance">
                </td>
                <td>
                    <button onclick="validateInput('J')">Verify</button>
                </td>
            </tr>
        
    </table>
</div>

    
<script>
    const startNode = 'A';
    const dijkstraResult = dijkstra(startNode);
    var correctDistances = result.distances;
// var correctDistances = {'B': 11, 'C': 6, 'D': 9, 'E': 5, 'F': 12, 'G': 7, 'H': 4, 'I': 10, 'J': 2}; // Create a dictionary of correct distances for each node
var userAnswers = {'A': 0}; // Create a dictionary to store user inputs

// This function verifies user input against the correct distances
function validateInput(node) {
    var userInput = document.getElementById('distanceTo' + node).value;
    var distanceTable = document.getElementById('distanceTable');

    // If the user input is correct, store it and give feedback
    if (correctDistances[node] == userInput) {
        userAnswers[node] = userInput;
        alert('Correct! The distance to node ' + node + ' is ' + userInput + '.'); // Alert for correct input
        if (Object.keys(userAnswers).length === Object.keys(correctDistances).length + 1) {
            displayResults();
        } else {
            var nextNode = String.fromCharCode('A'.charCodeAt(0) + Object.keys(userAnswers).length);
            var nextInput = document.getElementById('distanceTo' + nextNode);
            if (nextInput) {
                nextInput.focus();
            }
        }
    } else {
        alert('Incorrect for node ' + node + '. Try again.'); // If  wrong, prompt for another try
    }
}

// This function displays the user's entered distances at the end
function displayResults() {
    var message = document.createElement('div');
    message.innerHTML = '<strong>Shortest distances from A:</strong><br>';
    Object.keys(userAnswers).sort().forEach(function(node) {
        message.innerHTML += 'Node ' + node + ': ' + userAnswers[node] + '<br>';
    });
    distanceTable.parentNode.insertBefore(message, distanceTable.nextSibling);
}
</script>

</body>
</html>
