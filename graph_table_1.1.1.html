<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest path Dijkstra algorithm by Ramo</title>
</head>

<body>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
        }

        #graphContainer {
            flex-grow: 1;
        }

        canvas {
            border: 1px solid black;
            width: 100%;
        }

        #output,
        #priorityQueueOutput {
            margin-top: 20px;
            font-family: Arial;
        }

        #distanceTable,
        #distanceTable th,
        #distanceTable td {
            border: 1px solid black;
            border-collapse: collapse;
            padding: 15px;
            flex: 1;
            position: relative;
            /*  fixes the position of the element relative to the browser window */
            top: 10;
            /* Specifies distance from top of window */
            right: 50;
            /* Specifies distance from right of window */
            margin-bottom: 20px;
        }

        #canvasContainer {
            flex: 1;
        }

        #mainContainer {
            display: flex;
            justify-content: center;
            /* Center the flex items horizontally */
            align-items: start;
            /* Align the flex items to the top */
        }


        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
    </style>

    <div id="mainContainer">
        <canvas id="graphCanvas" width="800" height="600"></canvas>
        <div id="inputOutputContainer">
            <div id="outputDiv"></div>

            <script> // contains the graph and the table

                let canvas = document.getElementById('graphCanvas');
                let ctx = canvas.getContext('2d');
                let outputDiv = document.getElementById('output');

                var nodes = {
                    A: { x: 150, y: 300 },
                    B: { x: 250, y: 100 },
                    C: { x: 50, y: 150 },
                    D: { x: 250, y: 450 },
                    E: { x: 400, y: 300 },
                    F: { x: 350, y: 500 },
                    G: { x: 50, y: 450 },
                    H: { x: 550, y: 150 },
                    I: { x: 600, y: 450 },
                    J: { x: 750, y: 300 },
                    K: { x: 50, y: 50 },
                    L: { x: 520, y: 40 },
                    M: { x: 180, y: 30 },
                    N: { x: 500, y: 520 },
                    O: { x: 700, y: 520 },
                };

                const edges = [
                    { from: 'A', to: 'B' },
                    { from: 'A', to: 'C' },
                    { from: 'A', to: 'D' },
                    { from: 'A', to: 'G' },
                    { from: 'B', to: 'C' },
                    { from: 'B', to: 'D' },
                    { from: 'B', to: 'E' },
                    { from: 'B', to: 'H' },
                    { from: 'B', to: 'L' },
                    { from: 'B', to: 'M' },
                    { from: 'C', to: 'G' },
                    { from: 'C', to: 'K' },
                    { from: 'D', to: 'F' },
                    { from: 'D', to: 'E' },
                    { from: 'D', to: 'I' },
                    { from: 'D', to: 'G' },
                    { from: 'E', to: 'H' },
                    { from: 'E', to: 'I' },
                    { from: 'E', to: 'J' },
                    { from: 'F', to: 'G' },
                    { from: 'F', to: 'I' },
                    { from: 'F', to: 'N' },
                    { from: 'H', to: 'J' },
                    { from: 'I', to: 'J' },
                    { from: 'I', to: 'N' },
                    { from: 'I', to: 'O' },
                    { from: 'K', to: 'M' },
                    { from: 'L', to: 'H' },
                    { from: 'L', to: 'J' },
                    { from: 'M', to: 'L' },
                    { from: 'N', to: 'O' },
                    { from: 'O', to: 'J' },


                ];

                edges.forEach(edge => {
                    edge.weight = Math.floor(Math.random() * 14 + 1);
                });

                //========================================================================= Dijkstra Priority queue  ========================================================================================================

                class PriorityQueue {
                    constructor() {                                                          // constructor initializes an empty queue
                        this.queue = [];
                    }

                    enqueue(element, priority) {                                            // adds element to queue with a given priority and sorts them      
                        this.queue.push({ element, priority });
                        this.sort();
                    }

                    dequeue() {                                                            // removes the first element (highest priority) from array
                        if (this.isEmpty()) {                                              // checks if queue is empty
                            return "Queue is empty";
                        }
                        return this.queue.shift().element;                                // removes first element
                    }

                    isEmpty() {
                        return this.queue.length === 0;
                    }

                    sort() {                                                            // output difference of priority and sort -> if negative, a has a higher priority than b
                        this.queue.sort((a, b) => a.priority - b.priority);
                    }

                    printQueue() {                                                      // prints the elements in the queue
                        this.queue.forEach(item => {
                            console.log(item.element);
                        });
                    }
                }
                function dijkstra(start) {
                    const distances = {};                                               // shortest dist from start to each node
                    const prev = {};                                                    // prev node in the shortest path to each node
                    const priorityQueue = new PriorityQueue();                          // manages the visited nodes

                    Object.keys(nodes).forEach(node => {                                // iterates over nodes and sets starting parameter
                        distances[node] = Infinity;
                        prev[node] = null;
                    });

                    distances[start] = 0;                                               // distance start node to itself
                    priorityQueue.enqueue(start, 0);                                    // adds start node to pq with rank 0

                    // Dijsktras Algorithm 
                    while (!priorityQueue.isEmpty()) {                                  // sets condition while loop true if not empty! -!
                        let current = priorityQueue.dequeue();                          // dequeues highest pq node

                        // iterates over edges and filters only conencted nodes to current node
                        edges.filter(edge => edge.from === current || edge.to === current).forEach(edge => {
                            let otherNode = edge.from === current ? edge.to : edge.from;                                // checks "from" "to" edges of nodes
                            let weight = edge.weight; // retreives weight curr edge

                            if (distances[current] + weight < distances[otherNode]) {                                   // if true shorter path is found
                                distances[otherNode] = distances[current] + weight;                                     // updates with shorter path
                                prev[otherNode] = current;
                                priorityQueue.enqueue(otherNode, distances[otherNode]);                                 // enqueues with updated distance
                            }
                        });
                    }

                    return { distances, prev };                                                                           // prev has no further function in programm -> const prev = new map() ...
                }

                // Drawing a line between two nodes to represent the edge.
                edges.forEach(edge => {
                    ctx.beginPath();
                    ctx.moveTo(nodes[edge.from].x, nodes[edge.from].y);
                    ctx.lineTo(nodes[edge.to].x, nodes[edge.to].y);
                    ctx.stroke();
                    let midX = (nodes[edge.from].x + nodes[edge.to].x) / 2;
                    let midY = (nodes[edge.from].y + nodes[edge.to].y) / 2;
                    ctx.font = '20px Arial';
                    ctx.fillText(edge.weight, midX, midY);
                });

                // Drawing the nodes as circles
                for (let node in nodes) {
                    ctx.beginPath();
                    ctx.arc(nodes[node].x, nodes[node].y, 20, 0, 2 * Math.PI);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.stroke();
                    ctx.fillStyle = 'black';
                    ctx.font = '20px Arial';
                    ctx.fillText(node, nodes[node].x - 10, nodes[node].y + 7);
                }


                //========================================================================= table canvas ========================================================================================================
            </script>

            <div id="inputContainer">
                <h3>Enter the shortest distance from node A to the next node:</h3>
                <input type="text" id="distanceInput" placeholder="Distance">
                <button onclick="validateAndProceed()">Next</button>
            </div>

            <script>
                // starts algorithm from start node A
                const startNode = 'A';
                const result = dijkstra('A');
                const dijkstraResult = dijkstra(startNode);                                   // ?stores the result of the dijkstra algorithm in a variable?
                var correctDistances = result.distances;
                var userAnswers = { 'A': 0 };                                                     // creates data type dict with A set to 0


                let nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O']; // Add or remove nodes as needed

                let currentIndex = 0;
                let distances = {};

                function validateAndProceed() {
                    let input = document.getElementById('distanceInput');
                    let distance = input.value;

                    // Validate input
                    if (isNaN(distance) || distance < 0) {
                        alert('Please enter a valid number');
                        return;
                    }
                }
                // Save distance
                distances[nodes[currentIndex]] = distance;

                // Move to next node
                currentIndex++;

                // Update prompt
                if (currentIndex < nodes.length) {
                    document.getElementById('inputContainer').children[0].innerText =
                        `Enter the shortest distance from node A to node ${nodes[currentIndex]}:`;
                    input.value = '';
                }

                let distances = {};

                function validateAndProceed() {
                    let input = document.getElementById('distanceInput');
                    let distance = input.value;

                    // Validate input
                    if (isNaN(distance) || distance < 0) {
                        alert('Please enter a valid number');
                        return;
                    }

                    // Save distance
                    distances[nodes[currentIndex]] = distance;

                    // Move to next node
                    currentIndex++;

                    // Update prompt
                    if (currentIndex < nodes.length) {
                        document.getElementById('inputContainer').children[0].innerText =
                            `Enter the shortest distance from node A to node ${nodes[currentIndex]}:`;
                        input.value = '';
                    } else {
                        alert('All distances have been entered');
                        input.disabled = true;
                    }
                }

            </script>
</body>

</html>