
//=========================================================================  Text ========================================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Shortest path Dijkstra algorithm by Ramo</title>
    <style>  
        body {
            margin: 0;
            display: flex;
            justify-content: space-between;
        }
        #graphContainer {
            flex-grow: 1;
        }
        canvas {
            border: 1px solid black;
            width: 100%;
        }
        #sideContainer {
            width: 300px; /* Adjust the width as needed */
            padding: 20px;
            box-sizing: border-box;
            text-align: left;
        }
        #output, #priorityQueueOutput {
            margin-top: 20px;
            font-family: Arial;
        }
        #distanceTable, #distanceTable th, #distanceTable td {
            border: 1px solid black; border-collapse: collapse; padding: 5px;
        }
        #distanceTable {
            margin-bottom: 20px;
        }
        input {
            margin-right: 10px;
        }
    </style>
</head>

<body>
    <div id="mainContainer"> 
        <canvas id="graphCanvas" width="800" height="600"></canvas>
        <div id="inputOutputContainer"> 
            <div id="outputDiv"></div> 
        
            <script> // contains the graph and the table
                let canvas = document.getElementById('graphCanvas');
                let ctx = canvas.getContext('2d');
                let outputDiv = document.getElementById('output');

                const nodes = {
                    A: { x: 150, y: 300 },
                    B: { x: 250, y: 150 },
                    C: { x: 50, y: 150 },
                    D: { x: 250, y: 450 },
                    E: { x: 400, y: 300 },
                    F: { x: 350, y: 500 },
                    G: { x: 50, y: 450 },
                    H: { x: 550, y: 150 },
                    I: { x: 600, y: 450 },
                    J: { x: 750, y: 300 },
                };

                const edges = [
                    { from: 'A', to: 'B' },
                    { from: 'A', to: 'C' },
                    { from: 'A', to: 'D' },
                    { from: 'B', to: 'C' },
                    { from: 'B', to: 'D' },
                    { from: 'B', to: 'E' },
                    { from: 'B', to: 'H' },
                    { from: 'C', to: 'G' },
                    { from: 'D', to: 'F' },
                    { from: 'D', to: 'E' },
                    { from: 'E', to: 'H' },
                    { from: 'E', to: 'I' },
                    { from: 'E', to: 'J' },
                    { from: 'F', to: 'G' },
                    { from: 'F', to: 'I' },
                    { from: 'G', to: 'I' },
                    { from: 'G', to: 'D' },
                    { from: 'H', to: 'J' },
                    { from: 'I', to: 'J' },
                ];
                
                edges.forEach(edge => {
                    edge.weight = Math.floor(Math.random() * 31 + 1);
                });
       
var Graph = (function (undefined) {

	var extractKeys = function (obj) {
		var keys = [], key;
		for (key in obj) {
		    Object.prototype.hasOwnProperty.call(obj,key) && keys.push(key);
		}
		return keys;
	}

	var sorter = function (a, b) {
		return parseFloat (a) - parseFloat (b);
	}

	var findPaths = function (map, start, end, infinity) {
		infinity = infinity || Infinity;

		var costs = {},
		    open = {'0': [start]},
		    predecessors = {},
		    keys;

		var addToOpen = function (cost, vertex) {
			var key = "" + cost;
			if (!open[key]) open[key] = [];
			open[key].push(vertex);
		}

		costs[start] = 0;

		while (open) {
			if(!(keys = extractKeys(open)).length) break;

			keys.sort(sorter);

			var key = keys[0],
			    bucket = open[key],
			    node = bucket.shift(),
			    currentCost = parseFloat(key),
			    adjacentNodes = map[node] || {};

			if (!bucket.length) delete open[key];

			for (var vertex in adjacentNodes) {
			    if (Object.prototype.hasOwnProperty.call(adjacentNodes, vertex)) {
					var cost = adjacentNodes[vertex],
					    totalCost = cost + currentCost,
					    vertexCost = costs[vertex];

					if ((vertexCost === undefined) || (vertexCost > totalCost)) {
						costs[vertex] = totalCost;
						addToOpen(totalCost, vertex);
						predecessors[vertex] = node;
					}
				}
			}
		}

		if (costs[end] === undefined) {
			return null;
		} else {
			return predecessors;
		}

	}

	var extractShortest = function (predecessors, end) {
		var nodes = [],
		    u = end;

		while (u !== undefined) {
			nodes.push(u);
			u = predecessors[u];
		}

		nodes.reverse();
		return nodes;
	}

	var findShortestPath = function (map, nodes) {
		var start = nodes.shift(),
		    end,
		    predecessors,
		    path = [],
		    shortest;

		while (nodes.length) {
			end = nodes.shift();
			predecessors = findPaths(map, start, end);

			if (predecessors) {
				shortest = extractShortest(predecessors, end);
				if (nodes.length) {
					path.push.apply(path, shortest.slice(0, -1));
				} else {
					return path.concat(shortest);
				}
			} else {
				return null;
			}

			start = end;
		}
	}

	var toArray = function (list, offset) {
		try {
			return Array.prototype.slice.call(list, offset);
		} catch (e) {
			var a = [];
			for (var i = offset || 0, l = list.length; i < l; ++i) {
				a.push(list[i]);
			}
			return a;
		}
	}

	var Graph = function (map) {
		this.map = map;
	}

	Graph.prototype.findShortestPath = function (start, end) {
		if (Object.prototype.toString.call(start) === '[object Array]') {
			return findShortestPath(this.map, start);
		} else if (arguments.length === 2) {
			return findShortestPath(this.map, [start, end]);
		} else {
			return findShortestPath(this.map, toArray(arguments));
		}
	}

	Graph.findShortestPath = function (map, start, end) {
		if (Object.prototype.toString.call(start) === '[object Array]') {
			return findShortestPath(map, start);
		} else if (arguments.length === 3) {
			return findShortestPath(map, [start, end]);
		} else {
			return findShortestPath(map, toArray(arguments, 1));
		}
	}

	return Graph;

})();









































































































